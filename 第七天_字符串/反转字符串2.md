# 反转字符串2
力扣541
## 初步思路
题目意思就是说捏，我要每隔2k个去反转前k个（不反转后2k中的后k个），如果发现剩下的不够2k了，但是大于k个，就反转前k个就行，如果剩下k个不够了，就全部反转

首先这个条件一堆，但都是反转，所以先写个单独的反转a-b的函数就行，

然后我们需要判定一些条件，应该需要一些计算的技巧吧。比如说，一个长度是n，我用n去除2k，情况应该分为以下几种：

1:不够除的，即2k>n,那么用n和k比，如果大于k，就反转k个，后面不变就行，如果小于k个，就全部反转

2:够除的，就写一个循环，按照要求，每隔k个就反转一下，然后算余数和k比较就行

注意一下，除是//，取余是%

```python 
def reverseStr(self, s: str, k: int) -> str:
    s= list(s)
    n = len(s)
    if n<k:
        self.reverse(s,0,n-1)
    elif k<=n<2*k:
        self.reverse(s,0,k-1)
    else:
        loop,rest = n//(2*k), n%(2*k)
        for i in range(loop):
            self.reverse(s,i*2*k,i*2*k+k-1)
        if rest<k:
            self.reverse(s,loop*2*k,n-1)
        elif k<=rest<2*k:
            self.reverse(s,loop*2*k,loop*2*k+k-1)
    return "".join(s)

def reverse(self,s,a,b):#把字符串的第a到b位反转
    l,r = a,b
    while l <r:
        s[l],s[r] = s[r],s[l]
        l+=1
        r-=1

```

注意，做完loop后，后面的是从loop*2k开始的

此外，s[l],s[r] = s[r],s[l]这一套是无法对字符串直接操作的，

"".join(s_list) 的完整语义是：“请用『空字符串（什么都没有）』作为胶水，把 s_list 里的每一个字符积木紧紧粘在一起。”