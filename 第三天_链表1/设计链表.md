# 设计链表

这个是要设计一些方法，包括增删改查之类的，先看一下最后要哪些

get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。

addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。

void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。

void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。


deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。

观察一下，其实还不算是很难，一个一个来

首先是第一个，获取下标是index的值，这个可以直接一个while遍历index遍就行，然后吐出来

第二个要求插入第一个元素之前，也是very的简单，直接让ListNode(val).next = head,就行吧

第三个要求插入末尾，也是very的简单，while循环遍历链表到None的时候，将cur.next = ListNode(val)就行

第四个，那么先要判断这个链表长度等于多少啊，while循环判断出来，然后分析插入位置，一个while循环到index，cur.next = temp, cur.next= ListNode(val),cur.next.next = temp就行


第五个 根据判断的，index，循环到位置，然后一个cur.next = cur.next.next  

## 看答案

看了答案后发现不是。自己刚才的想法是把这个当作函数来去对一个链表操作了，实际上是自己缺乏面向对象的编程思想，即关于size的处理在对象的初始化里面来去做

``` python 
class ListNode:
    def __init__(self,val = 0, next = None):
        self.val = val
        self.next = next

class MyLinkedList:

    def __init__(self):
        self.dummy_head = ListNode()
        self.size = 0

    def get(self, index: int) -> int:
        if index <0 or index >= self.size:
            return -1
        cur = self.dummy_head.next
        for i in range(index):
            cur = cur.next
        return cur.val


    def addAtHead(self, val: int) -> None:
        self.dummy_head.next = ListNode(val,self.dummy_head.next)#这里注意，我们的虚拟节点永远是虚拟节点
        self.size += 1

    def addAtTail(self, val: int) -> None:
        cur = self.dummy_head
        while cur.next:
            cur = cur.next
        cur.next = ListNode(val)
        self.size += 1

    def addAtIndex(self, index: int, val: int) -> None:
        if index <0 or index > self.size:
            return 
        cur = self.dummy_head
        for i in range(index):
            cur = cur.next
        temp = cur.next
        cur.next = ListNode(val)
        cur.next.next = temp
        self.size += 1
    def deleteAtIndex(self, index: int) -> None:
        if index <0 or index >= self.size:#删除index为size的也删除不了
            return
        
        cur = self.dummy_head
        for i in range(index):
            cur = cur.next
        cur.next = cur.next.next
        self.size -= 1
        
        



```

