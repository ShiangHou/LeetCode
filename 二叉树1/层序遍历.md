# 层序遍历

BFS 宽度优先遍历

## 基本的BFS思路

首先我们准备一个队列，先把root放进去，然后做如下事情

1）弹出X

2）X有左，加左，有右，加右，然后重复1）

这样就可以按照层来去返回（即先root，再root左，root右，由于每次加的和弹出的时候都把自己的左右压进去了，并且顺序也是按照层级来的）

但是这样没有按照题目要求的子list统计是在那一层

我们可以统计每一个node进来的时候是第几层，因为当一个链表弹出的时候，他的两个孩子会加进来，孩子的层是父亲的层+1,我们可以用一个hash来去完成这个事情

梳理一遍思路
首先建立一个hash，一个ans，一个deque，先把root加进队列，同时在hash的key记录root，value记录0

开始while deque不是空，
弹出，查看弹出的元素在hash中的key值，从而在ans的下标中加入

左右入队列，并且左右都作为hash的key统计value，value每次弹出循环并+1，这个可以全局统计

```python 
def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        dq = deque()
        ans = []
        level = {}
        dq.append(root)
        level[root] = 0
        while dq:
            #先弹出并记录在ans
            temp = dq.popleft()
            if level[temp] == len(ans):#如果是第一次出现，就新建一个
                ans.append([temp.val])
            else:#如果ans的这层不是第一次出现，直接把元素加进去就行
                ans[level[temp]].append(temp.val)
            if temp.left:
                dq.append(temp.left)
                level[temp.left] = level[temp]+1
            if temp.right:
                dq.append(temp.right)
                level[temp.right] = level[temp]+1
        return ans

```

注意一下判断的方法，用len(ans)来去判断