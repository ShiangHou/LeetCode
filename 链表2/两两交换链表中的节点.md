# 两两交换链表中的节点
力扣24

## 初步思路
感觉拿着纸和笔画一画就出来了

先看一下两个指针能不能完成，准备一个pre和一个cur

当cur遍历到中间的时候，我们需要交换cur与cur.next

第一步，将pre与cur.next相连接，即pre.next = cur.next

第二步，将cur和 下下一个连接，即cur.next = cur.next.next

第三步，将cur的下一个指向cur，注意到pre的下一个已经指向cur的下一个了，因此就是 pre.next.next = cur

第四步，移动指针，注意到pre需要到cur的位置，然后cur跳一个就行，所以就是pre = cur，cur = cur.next

梳理完步骤后，我们需要处理一下头节点在最开始的时候，pre为None，cur为head，做完第一次后，我们需要将cur.next那一个存一下ans就行

头节点的情况比较特殊，cur为第一个的时候，就没有pre，所以这时直接让cur指向下下一个，然后cur的下一个指向cur就行，注意用一个变量来接住cur.next作为最后的返回值

```python 
def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
    if head == None or head.next == None   :#只有一个元素，直接返回就行
        return head
    pre = None
    cur = head
    ans = None
    #开始，先处理头节点
    temp = cur.next
    cur.next = cur.next.next
    temp.next = cur
    pre = cur
    cur = cur.next
    while cur and cur.next:
        pre.next = cur.next
        cur.next = cur.next.next
        pre.next.next = cur
        pre = cur
        cur = cur.next
    return temp

```

## 优化

代码其实还有可以优化的空间，可以写一个递归，在递归中自然的判断头节点是不是None就行

需要反转的是pre和cur，此时先存一下下一步的需要反转的

_next = cur.next

然后开始反转就行

cur.next = pre

pre.next = 递归（_next)
return cur

```python 
def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
    if head == None or head.next == None   :#只有一个元素，直接返回就行
        return head
    pre = head
    cur = head.next
    _next = cur.next
    cur.next = pre
    pre.next = self.swapPairs(_next)
    return cur
```