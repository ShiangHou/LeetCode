# 两个数组的交集
力扣349
## 初步思路
在做过有效字母异位词后，这道题的思路也是比较清晰。题目要求我们去找到交集，我们可以依旧用一个数字的hash来去完成，即用一个数组的该数字的下标来去构建

但是问题涌现出来，如果一个数字很大的话，比如1亿，那么我就需要准备一个下标是1亿的数组

## 数字的ASCII
如果是0-9的话就好了，问了我的好厚米Gemini后，厚米说如果是一个长得是字符串的数组就可以，比如说“0”这个的ASCII就是48，9就是58，并且ASCII只能映射单个的字符，对于10这样的就不行

## 第一波思路
忽然注意到题目中下面写的

1 <= nums1.length, nums2.length <= 1000
0 <= nums1[i], nums2[i] <= 1000

意思就是说，每一个数组中数字的大小都是小于1000的，那就好办了，直接用数组构建一个hash就行了呗

所以说，遍历第一个数组，存进去，遍历第二个数组，存进去，然后再遍历一遍hash，将所有不是0的对应的下标都取出来就行了

注意到有一点问题，当第一个数组是 1 2 2 1的时候，第二个数组是2 2，那么单纯的将所有hash中不等于1的都返回会把1 2 都返回，这样是不行的，并且数组中的如果是自己重复的也会跟着记录

因此初步的思路是，第一个数组照常+1，第二个数组在遍历的时候如果发现不为0了，就直接变成-1就行，如果发现是-1了（即以及统计过了），就跳过就行

```python 
def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        hash_nums = [0] * 1001
        ans = []
        for i in nums1:
            hash_nums[i] += 1
        for j in nums2:
            if hash_nums[j] != 0:#说明出现了重复的
                hash_nums[j] = -1
            if hash_nums[j] == -1:#出现组内重复的了
                continue 
        for k in range(len(hash_nums)):
            if hash_nums[k] == -1:
                ans.append(k)

        return ans

```

## 进阶
```python 
def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
    return list(set(nums1) & set(nums2))
```
直接用集合去重后去交集就行
