# 二叉树的最小深度

力扣104
## 初步思路

刚才最大深度一直往下遍历就行，然后找到最大的max，现在最小深度肯定不能min，因为一开始是0，需要去控制递归返回的情况

总体思路依旧是，开始往下走，走到左右都是None的时候，返回自己走过的长度是多少，

所以写的时候，递归带着长度参数，如果左不是空，就递归，然后长度+1就行

```python 
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        return self.findmin(root,1)

    def findmin(self,node,depth):
        if not node.left and not node.right :
            return depth

        elif node.left and node.right:
            return min(self.findmin(node.left,depth+1),self.findmin(node.right,depth+1))
        elif node.left and not node.right:
            return self.findmin(node.left,depth+1)
        else:
            return self.findmin(node.right,depth+1)
```

有几个细节需要注意，在刚开始写的时候，大的使用了用了 min（左的深度，右的深度），其实是部队的，因为当一个node只有左没有右的时候，它需要一直往下探索。

所以说，min（左的深度，右的深度）应该写在递归里面，递归里面需要判断几种情况，一种是到底了，没有左右，直接返回深度，一种是左右都有，那么此刻才会返回min（左，右），如果左右只有一个，那么继续沿着+1往下走就行