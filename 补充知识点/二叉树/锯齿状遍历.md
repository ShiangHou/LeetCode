# 锯齿状遍历

力扣103

## 初步思路
这个跟层序遍历very的相似，都是一层一层，但是顺序不一样。在做层序遍历的时候，是先加左后加右，那么如果要是倒过来，那就是先加右后加左就行，

我们可以维护一个flag，也不用基数偶数那么复杂，因为就两种状态，直接0和1就行，0就是正常左右，1就是正常右左，当每循环一层的时候flag变一下就行


写了一下代码，其实有点问题

```python 
def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        dq = deque()
        ans = []
        flag = 0
        dq.append(root)
        while dq:
            size = len(dq)
            flag = 1 if flag == 0 else 0
            temp_ans = []
            for _ in range(size):
                temp_node = dq.popleft()
                temp_ans.append(temp_node.val)
                if flag == 0:#正常左右
                    if temp_node.left:
                        dq.append(temp_node.left)
                    if temp_node.right:
                        dq.append(temp_node.right)
                else:#右左、
                    if temp_node.right:
                        dq.append(temp_node.right)
                    if temp_node.left:
                        dq.append(temp_node.left)
            ans.append(temp_ans)
        return ans
```

问题在于，当右左完后，因为上一波是先弹出的右节点，那么右节点的左是先放进去的，但是层序遍历的下一层应该是左节点的左先进去

所以flag的思想是对的，但是我们原来的层序遍历的先加左后加右也不能动，因为这是一个基本的层序，不这么按照的话就会出错。

那么这个flag应该改动哪一个呢，注意到，我们把队列翻过来就行，或者说，用双端队列去从另一个头取就行，同时，如果是换了头去pop了，那么append的时候也要注意从另一个头的append

问了以下好厚米，直接appendleft就行，在脑海中想一下，deque正常的append是右加，pop也是右pop


```python 
def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        dq = deque()
        ans = []
        flag = 0#是1的话说明该反转了
        dq.append(root)
        while dq:
            size = len(dq)
            flag = 1 if flag == 0 else 0
            temp_ans = []
            for _ in range(size):
                if flag == 0:#正常左右
                    temp_node = dq.popleft()#队列是左出右加
                    temp_ans.append(temp_node.val)
                    if temp_node.left:
                        dq.append(temp_node.left)
                    if temp_node.right:
                        dq.append(temp_node.right)
                else:#右左
                    temp_node = dq.pop()#队列是右出左加
                    temp_ans.append(temp_node.val)#这个是收集ans的正常不要动
                    if temp_node.left:
                        dq.appendleft(temp_node.left)
                    if temp_node.right:
                        dq.appendleft(temp_node.right)

            ans.append(temp_ans)
        return ans
```

其实还是不对,让进入队列里面的时候，进入乱了，从左进去，又从左弹出，事实上，应该最小话的可能，即直接反着收集就行，队列应该是正常加，正常pop的事情，

换成代码，应该先反着收集完所有的，然后正常加就行，即flag先控制一下收集，然后在正常弹出就行

```python 
def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
    if not root:
        return []
    dq = deque()
    ans = []
    flag = 0#是1的话说明该反转了
    dq.append(root)
    while dq:
        size = len(dq)
        flag = 1 if flag == 0 else 0
        temp_ans = []
        #先收集，
        if flag == 0:#正常左右收集,注意队列是右边往左加的，反着的，所以正常收集是反着的
            for i in range(size-1,-1,-1):
                temp_ans.append(dq[i].val)
        else:#反着收集
            for i in range(size):
                temp_ans.append(dq[i].val)
        #然后正常的BFS
        for _ in range(size):
            temp_node = dq.popleft()#只需要弹出，不需要收集
            if temp_node.left:
                dq.append(temp_node.left)
            if temp_node.right:
                dq.append(temp_node.right)
        ans.append(temp_ans)
    return ans


```