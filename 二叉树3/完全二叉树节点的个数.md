# 完全二叉树节点的个数

力扣222
## 初步思路

遍历一遍不就完了嘛，然后统计一下就行

看一下题目，挑战我们用小于O(n)的复杂度，遍历一遍的复杂度是O(n)

那既然如此，肯定是要用完全二叉树的性质啊，是吧

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（从第 0 层开始），则该层包含 1~ 2h 个节点。

## 思路

看了左程云，有点类似于二分

先说一个公式，对于一个满完全二叉树，层数是n，那么数量是2的n次方-1

首先先不断地跑left，跑出来树的高度，然后做一下两个操作


不断找root.right的左，

1）如果发现到了高度，那么说明root的左边是满的，此时有公式，2的n-1次方-1（即去掉root后的左子树是满二叉树，的计算公式），同时递归调用这个函数，传入root.right作为根节点就行（2的n-1次方-1 +1（即加上root） +递归函数。

2）如果发现没到高度，那么说明右边这棵树只到了层-1层，那么右子树的和是2的n-2次方-1的数量，同时，我们递归调用root.left 作为root节点，即（2的n-2次方-1 +1（即加上root+递归函数）

```python 
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        return self.find(root,1,self.mostleft(root,0))


    
    def find(self,cur,level,h):#cur是当前的node，level是该node在第几层,h是这个整棵树的总深度
        if level == h:#如果以及到了最深了，返回1
            return 1
        #如果右节点往左扎，扎到了最深
        if self.mostleft(cur.right,level) == h:
            #那么以改课树的左是满的，递归右就行
            return 2**(h-level) + self.find(cur.right,level+1,h)
        else:#如果右节点往左扎没扎满，
            #那么右节点层数-1 的数量，然后递归调用cur的左
            return 2**(h-level-1) + self.find(cur.left,level+1,h)

            


        #先找右的左
    def mostleft(self,node,level):#不停往左能到几层
        while node:
            level +=1
            node = node.left
        return level

```

注意几点，首先递归的时候带着level（当前节点的层），h，最后计算子树的时候，是h-level，即剩下的二叉树的深度