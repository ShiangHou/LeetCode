# 长度最小的子数组
力扣209 https://leetcode.cn/problems/minimum-size-subarray-sum/description/

## 初版思路
题目要求找到数字和大于target的，一个想法是，首先我用两个指针，同时维护一个sum用来记录当前数组的值的大小，由于开始的时候两个指针都指向0，所以一开始的sum也是nums[0]、

思路是，一个快指针，一个慢指针，如果快慢指针之间维护的数组满足条件，就让慢指针往前后，然后继续判断（看看删除掉慢的满不满足了），如果发现不满足，就让fast往前走，继续探路

用一个while循环控制前指针，开始的时候滑动，并且判断

1:如果当前sum 大于等于 target，就让更新ans = min(ans,r-l+1),同时将后指针指向的元素删除 

2:如果发现没大于，让r++就行，往前探路，注意边界

最后return的时候，如果ans还是正无穷，说明没有更新，直接返回0就行

```python 
def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        if not nums:
            return 0
        l,r = 0,0
        ans = float("inf")
        temp = nums[0]
        while r < len(nums):
            if temp >= target:
                ans = min(ans,r-l+1)
                temp -= nums[l]
                l+=1
            else:
                r+=1
                if r <= len(nums)-1:
                    temp+=nums[r]
        return ans if ans != float('inf') else 0
```

## 更好的写法

观察一下可以发现，思路是对的，但代码可以更好一些，整体写一个while循环，开始的时候加上fast的值就行，然后一个while判断满不满足，不满足的话就继续加，满足的话就退出来，让slow跟上去

```python 
def minSubArrayLen(self, target: int, nums: List[int]) -> int:
    temp = 0
    ans = float('inf')
    slow,fast = 0,0
    while fast < len(nums):
        temp += nums[fast]
        while temp >= target:
            ans = min(ans,fast-slow+1)
            temp -= nums[slow]
            slow += 1
        fast += 1
    
    return ans if ans != float('inf') else 0

```
