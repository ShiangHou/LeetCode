# 层序遍历

BFS 宽度优先遍历

## 基本的BFS思路

首先我们准备一个队列，先把root放进去，然后做如下事情

1）弹出X

2）X有左，加左，有右，加右，然后重复1）

这样就可以按照层来去返回（即先root，再root左，root右，由于每次加的和弹出的时候都把自己的左右压进去了，并且顺序也是按照层级来的）

但是这样没有按照题目要求的子list统计是在那一层

我们可以统计每一个node进来的时候是第几层，因为当一个链表弹出的时候，他的两个孩子会加进来，孩子的层是父亲的层+1,我们可以用一个hash来去完成这个事情

梳理一遍思路
首先建立一个hash，一个ans，一个deque，先把root加进队列，同时在hash的key记录root，value记录0

开始while deque不是空，
弹出，查看弹出的元素在hash中的key值，从而在ans的下标中加入

左右入队列，并且左右都作为hash的key统计value，value每次弹出循环并+1，这个可以全局统计

```python 
def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        dq = deque()
        ans = []
        level = {}
        dq.append(root)
        level[root] = 0
        while dq:
            #先弹出并记录在ans
            temp = dq.popleft()
            if level[temp] == len(ans):#如果是第一次出现，就新建一个
                ans.append([temp.val])
            else:#如果ans的这层不是第一次出现，直接把元素加进去就行
                ans[level[temp]].append(temp.val)
            if temp.left:
                dq.append(temp.left)
                level[temp.left] = level[temp]+1
            if temp.right:
                dq.append(temp.right)
                level[temp.right] = level[temp]+1
        return ans

```

注意一下判断的方法，用len(ans)来去判断

## 优化思路
首先上面那个需要新申请一个空间，此外也是very的慢，考虑优化

我们在之前学习队列的时候，学过用一个数组+两个指针去模拟一个队列，回忆一下

首先需要申请一个很大的数组，准备两个指针l和r，开始的时候l和r都指向0

如果入队列，就入到r位置，然后r++

如果出队列，就弹出l的位置，然后l++

回到本题，我们有一个很好的做法来去做，需要维护一个队列的大小size。先说流程

首先先把root加入到队列中去，此时size为1

1）拿到队列长度size

2）以下过程重复size次：弹出，有左加左，有右加右

### 原理

思考一下这个流程原理，其实不难理解。队列里面维护的**size是这一层有多少个元素**，比如说，当size为1时，弹出size，左右加进来，此时size为2，那么重复size遍就相当于是把当前的size个都弹了出来，子节点的所有子节点都加入，因为新加入的是同一层，所有新加入的构成了新的一层，并且他们的数量就是size，后面的重复size遍就是要把他们都处理完成再处理下一层

梳理一下思路，想一下能不能不用数组用deque来去写

首先需要准备一个deque，一个ans用来返回答案，

首先root加入到deque，然后先拿到当前的len

这个len是会随着弹出一个再加一个去变化的，所以考虑写在外面

然后开始一个循环


```python 
def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
    if not root:
        return []
    dq = deque()
    ans = []
    dq.append(root)
    while dq:
        size = len(dq)
        temp_ans = []
        for _ in range(size):
            temp_node = dq.popleft()
            temp_ans.append(temp_node.val)
            if temp_node.left:
                dq.append(temp_node.left)
            if temp_node.right:
                dq.append(temp_node.right)
        ans.append(temp_ans)
    return ans
```

这里的训练用while dq就行，如果dq没有值了，说明没有node了，整体的思路-代码还是very的清晰
