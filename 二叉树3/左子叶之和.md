# 左子叶之和
力扣404
## 初步思路

首先是所有的左子叶

第一个想到的是层序遍历，当层序遍历的时候对于最先pop的收集起来就行，但是其实是不对的，因为这样只是每一层的第一个，对于里面的左子叶是无法获取的，所以还是老实思考递归之类的把

换句话说，我需要遍历所有的，直到找到所有的左数，因为右子树也有可能有左子树，除非左右都没有的时候才结束

此外，我们统计的时候，最好在父节点就统计好，这样终止条件好写

```python 
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.findleft(root)
        return self.ans
    
    def findleft(self,node):
        if not node.left and not node.right:
            return 
        if node.left:
            self.ans += node.left.val
            self.findleft(node.left)
        if node.right:
            self.findleft(node.right)
```

写好后发现[1,2,3,4,5]过不了

阅读一遍题目后发现，所谓的左子树是要求，比如node的左右都是None，此时他才算是左子树

那么简单改一改，加一个判断条件就行，即node.left的左右都没有的时候才收集

```python 
def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:
        self.ans = 0
        self.findleft(root)
        return self.ans
    
    def findleft(self,node):
        if not node.left and not node.right:
            return 
        if node.left:
            if not node.left.left and not node.left.right:
                self.ans += node.left.val
            else:
                self.findleft(node.left)
        if node.right:
            self.findleft(node.right)

```