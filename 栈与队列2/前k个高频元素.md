# 前k个高频元素
力扣347
## 初步思路
复述一下题目，给了我一串数组，让我返回出这个数组中出现频率前k高的元素

首先肯定是要都扫一遍，统计元素以及元素的频率

然后，根据频率，进行排序，直接返回k个就行

排序的算法是nlogn，但是这题放在了队列里面，是不是可以用队列来去优化，

## 最优解法
看了一下，可以用小顶堆来去写，时间复杂度可以优化到nlogk

所谓堆，就是一个完全的二叉树，小顶堆就是说，父节点始终是小于左右子节点的（但是左右节点之间的大小关系并不关心）

为什么能达到nlogk? 首先，传统排序是把n个都排序，但是现在只要求前k个，所以剩下的n-k个都相当于是无效

此外，既然父节点的左右子节点，那最后怎么返回出按照k个顺序呢（即k内部怎么排序）。

其实只需要每次pop就行，堆会自己调整，详细的见补充知识点的堆里面

## 思路
整理一下思路，首先需要将数组遍历一遍，用一个dict存着，key放数字，value放出现的次数，然后需要把次数**依次**扔到一个长度是k的最小堆里面（即省去了排序的过程），由于需要找次数最大的k，放入堆的逻辑是这样

首先堆是空的，放入就放在顶，加进来一个，如果堆没满，就和父节点比较就行（用python的话直接用自己实现的，然后直接扔进去就行）

当堆满的时候，此时如果再放入一个，如果比较发现比根节点大，就让根节点滚蛋，自己当根节点，然后下沉

如果发现比根节点小，就不放，继续往下遍历就行

逻辑是这样的，由于是最小堆，根节点存放的是最小的，两个子节点都比较大，即根节点是k个中那个随时需要滚蛋的，如果来了一个比根节点大，说明根节点可以滚蛋了，因为此时新来的+原来k-1个才是k个大的，如果新来的没有根节点大，即新来的连现在k个中最小的都比不过，那么就无法加入我们

有个新问题，怎么将次数和元素对应，因为刚才的建立的字典是元素-频率

直接反转过来就行

不行，因为有一个问题，会导致hash冲突，即如果反转后有重复的，那么会直接覆盖

Gemini和我说，直接将一个tuple(freq, num)扔进堆里面，因为此时堆会按照第一个来去比较


```python 
def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        #首先统计
        fre_dict = {}
        for i in nums:
            if i not in fre_dict:
                fre_dict[i] = 1
            fre_dict[i] += 1
        #然后打入到堆里面,边打边统计
        ans = []
        for value,freq in fre_dict.items():
            heapq.heappush(ans,(freq,value))
            if len(ans) > k:
                heapq.heappop(ans)
        return [item[1] for item in ans]

```

注意，这里有个小巧思，先放入，在判断，刚才我们说放入的如果和顶比较小的话就弹出不放入，这里其实可以先放入，因为放入就自动排好序了，如果超了，就直接弹出就行，相当于无脑放入4个，斩杀掉最小的，