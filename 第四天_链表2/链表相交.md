# 链表相交

## 初步思路

首先这题之前做过有印象，分析一下可以发现，两条链表的后半部分长度是一样的，那么先都一起走一遍（走一遍的时候如果发现==了，直接返回）计算一个差值，并且找到一个最先到达None的那个作为长的，然后让那个短的++差值，然后再一起走，这样就可以找到遇到==直接返回，如果发现一直没有==，直接返回None

```python 
 def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None
        l1 = headA
        l2 = headB
        #统计长度
        step1,step2 = 0,0
        while l1.next!= None:
            l1 = l1.next
            step1+=1
        while l2.next!= None:
            l2 = l2.next
            step2+=1
        #分配长度
        _long = headA if step1 >= step2 else headB
        _short = headB if _long == headA else headA
        dif = abs(step1-step2)
        #long先走
        for i in range(dif):
            _long = _long.next

        #俩人一起走，直到相等
        ans = None
        while _short and _long:
            if _short == _long:
                ans = _short
                break
            _short = _short.next
            _long = _long.next
        return ans

```