# 有序数组的平方
力扣 977

## 初步思路
首先要求n的复杂度，可以想到，如果我把数组先平方了，然后再排序，那么排序的算法一般就是nlogn的复杂度，最后的复杂度就是n+nlogn，即nlogn，不满足题意，所以说还是要先根据未平方前的数组弄好序列，最后刷一遍就行，这就是最暴力的解法

现在问题转换成，将一个正负有序的数按照绝对值大小排好序，时间复杂度要求是n。思考这个排序的问题，

### 想法一
不难发现，这个数组的前半部分天然就是有序的，即从-到0这个阶段，所以说我们是不是可以先让slow停在0处，然后fast走到正的部分）即第一个正值，然后不断比较二者

但这样的问题是，从绝对值来看，负的地方是递减的，正的地方是递增的，所以说这样是不行的，那么可以考虑换过来看，i从负的绝对值最小的，j从正的绝对值最大的来，但这样有个问题是，交换后小的要扔到什么位置上

回想归并排序的merge过程，左有序，右有序，让左右都有序的过程，这里其实很像，因为让左右都有序的复杂度是logn，所以说先平方也可也

即：首先平方，然后找到中间位置（0处，或者左正右负），如果没有，就直接反转输出就行

如果找到了，就把原来负的地方全部反转，然后开始归并排序的merge过程，即用两个指针，不断把小的放进去，最后刷回原数组就行

那么这个解法的一个关键在于怎么将数组反过来，其实就是nums[i:j+1] = nums[i:j+1][::-1]就行

分析，数组遍历一遍变平方是O(N),后面的归并排序的merge过程也是n，所以最后还是N的复杂度

```python
    def sortedSquares(self, nums: List[int]) -> List[int]:
        i = 0
        if nums[i] >=0: #那就不需要排序，直接平方就行
            for j in range(len(nums)):
                nums[j] = nums[j]*nums[j]
            return nums
        while i<len(nums):#找到0或者一负一正
            if nums[i] == 0:
                break
            if nums[i] >0 and nums[i-1] <0:
                break
            i+=1
        if i == len(nums)-1 and nums[i] <=0 :#说明前面已经都有序了,并且都是负的
            for j in range(len(nums)):
                nums[j] = nums[j]*nums[j]
            nums = nums[::-1]
            return nums 
        else:
            nums[0:i] = nums[0:i][::-1]#先把前面的反转
            #再平方
            for j in range(len(nums)):
                nums[j] = nums[j]*nums[j]
            #再做归并排序中的merge
            a,b = 0,i
            temp = []
            while a < i and b < len(nums):
                if nums[a]<=nums[b]:
                    temp.append(nums[a])
                    a+=1
                else:
                    temp.append(nums[b])
                    b+=1
            while a < i:
                temp.append(nums[a])
                a+=1
            while b < len(nums):
                temp.append(nums[b])
                b+=1
            return temp

```

## 双指针

升级，其实思想是一样的，回忆刚才我们的merge，其实可以只扫一遍就行

刚才陷入一个思维误区，必须要从负的绝对值最小和正的绝对值最小开始，从而需要找到那个所谓的“分割点”进而浪费了大量的精力

那么可不可以不招分割点捏，不找分割点的话就要从数组的两端开始，那么这里就不是比小了，而是”比大“因为两端的都是各自领域绝对值的最高点，进而不需要找到最小。

所以思路就是，先新建一个数组，然后两个指针从一头一尾开始，比谁的平方大，大的放在新数组的尾巴就行

```python 
def sortedSquares(self, nums: List[int]) -> List[int]:
        temp = [0] * len(nums)
        l,r,i = 0,len(nums)-1,len(nums)-1
        while l <= r:
            if  nums[l]**2 >= nums[r]**2:
                temp[i] = nums[l]**2
                i-=1
                l+=1
            else:
                temp[i] = nums[r]**2
                i-=1
                r-=1
        return temp
```

要注意的是，while要写l<=r，因为两个最后要重合才行，不然有漏的