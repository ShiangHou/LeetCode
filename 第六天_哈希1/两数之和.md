# 两数之和
力扣1

## 初步思路

首先当然是一个very标准的n2的复杂度的算法，对于每一个nums，往后遍历，如果没找到，就下一个，如果找到了，就直接return就行

```python 
def twoSum(self, nums: List[int], target: int) -> List[int]:
    for i in range(len(nums)):
        for j in range(i+1,len(nums)):
            if nums[i] + nums[j] == target:
                return [i,j]

```

当然有没有时间复杂度更小的呢，依旧是考虑hash
让我遍历到一个数的时候，在hash中存下这个数+这个数的下标以及target-这个数（下标弄成空）

当我继续遍历的时候，如果发现遍历的这个数在hash中存在了（说明是之前遍历target-i的时候存下来了这个数），此时就把这个数的下标和hash- target的下标返回就行

所以说需要一个字典存数和数的下标，字典

## 字典dict的用法
字典是一个键值对的hash，，并且支持key的去重
```python 
my_dict = {}
my_dict['1'] = 1#添加一个，如果没有key就自动添加
my_dict.get('2') #查询，如果不存在key就返回None
```

这题不能用set，因为比如3，3，set后就剩一个3了，对于一个target来说6就可以

梳理一遍思路，
首先遍历数字和下标，存在dict里面，然后判断dict里面有没有target-该数字的key，没有的话就继续，有的话直接返回就行

```python 
def twoSum(self, nums: List[int], target: int) -> List[int]:
    nums_dic = {}
    for i in range(len(nums)):
        if nums_dic.get(str(target-nums[i])):
            return [nums_dic[str(target-nums[i])],i]
        nums_dic[str(nums[i])] = i

```
这样写有一个问题，当返回是0的时候，也会将其判断为False！！
所以最好是用in来写，in只会检查有没有这个键

```python 
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_dic = {}
        for i in range(len(nums)):
            if str(target-nums[i]) in nums_dic:
                return [nums_dic[str(target-nums[i])],i]
            nums_dic[str(nums[i])] = i
```
当然也可以不用str来存，直接用数字来存key也可以