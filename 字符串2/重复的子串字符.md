# 重复的子串字符

力扣459
## 初步思路
题目描述 这道题让我们找到一个字符串是不是能够用自己本身的子串重复生成

说是用kmp，但我是呆b刚学会kmp，kmp只能返回子串的下标，怎么找重复生成啊

还是问一下好厚米吧

very的巧妙

对于一个满足条件的，比如abcabcabc，那么我们可以得到一个结论，字符串的长度-整个字符串的最长前后缀=重复的长度，这里就是，最长公共是6，总长度是9，最后的是3，即abc长度，证明如下

把 s 拆成 3 个部分（每个部分是一个 "abc"）：

s = [部分1] + [部分2] + [部分3]

因为前缀等于后缀，所以：

前缀是：[部分1] + [部分2]

后缀是：[部分2] + [部分3]

既然前缀和后缀一模一样，那就意味着对应的位置必须相等：

[部分1] 必须等于 [部分2]

[部分2] 必须等于 [部分3]

结论：[部分1] == [部分2] == [部分3]。字符串完美重复！

所以思路就是，只要我们求出来了整个字符串的最长公共前后缀（即原来的next数组的下标是n+1的位置），那么，如果这个前后缀是大于0的（即包含，假设前后缀是L），并且n与n-L是倍数关系（即可以右好几次来去实现），那么说明就满足


```python 
    def repeatedSubstringPattern(self, s: str) -> bool:
        n = len(s)
        if n <= 1:
            return False
        _next = [0]*(n+1)
        _next[0] = -1
        _next[1] = 0
        i = 2
        cn = 0
        while i <=n:
            if s[i-1] == s[cn]:
                cn += 1
                _next[i] = cn
                i += 1
            elif cn > 0:
                cn = _next[cn]
            else:
                _next[i] = 0
                i+=1
        L = _next[n]
        return True if L >0 and  n%(n-L) == 0 else False

```

## 一行
评论区的骚猪
假设母串S是由子串s重复N次而成， 则 S+S则有子串s重复2N次，

那么现在有： S=Ns， S+S=2Ns， 其中N>=2。

如果条件成立， S+S=2Ns, 掐头去尾破坏2个s，S+S中还包含2*（N-1）s, 又因为N>=2,

因此S在(S+S)[1:-1]中必出现一次以上



```python 
return s in (s+s)[1:-1]

```