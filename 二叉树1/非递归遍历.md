# 非递归遍历
题目依旧是那三个题目

## 思想

不用递归来去写二叉树的三个遍历，即要用到一个栈

思想就是，当我遍历到顺序的时候，把node压入，需要的时候就弹出

## 先序遍历-非递归

首先假设有一个二叉树 1 2 3 4 5 6（自己想想就行）

我们的流程是这样的，首先将root压入栈

while 栈不为空的时候

弹出node并且打印value，如果右不为空就压入right，如果左不为空就压入左，持续

原理是这样的，开始的时候压入[1],然后弹出1，并且压入[3,2]

弹出2，压入2的右左，即[3,5,4]，然后弹出4，压入4的右左，继续

原理是，先序遍历都要先处理自己所有的左，然后再处理自己，然后再处理自己的右，所以先压自己，然后压右左

压入右左的原因是，先序遍历需要中左右，但是栈是先进先出，所以先压右，后压左，这样出来的时候就是符合顺序的，即先出左，左出完出自己（因为自己也压进去了），再出右，正好

```python 
def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
    if root == None:
        return []
    stack = []
    stack.append(root)
    ans = []
    while stack:
        temp = stack.pop()
        ans.append(temp.val)
        if temp.right:
            stack.append(temp.right)
        if temp.left:
            stack.append(temp.left)
    return ans
```

## 中序遍历-非递归

中序遍历的流程如下

1）node自己，以及node所有的left全部压入栈，直到为None

2）栈弹出节点（并打印），然后针对右边的node，重复1（即把右边的node 自己，以及右边的node全部left都压入重复）

3）没有子树且栈为空

原理是，中序遍历都要先处理左边，再处理自己，再处理右边。这里先把自己和自己的所有left都压入，这样弹出的时候就会先弹出自己的left，再弹出自己。此外，左到末尾了会执行末尾的右，这样就完成了左中右（即node的所有左子树，node自己，node的所有右子树）

```python 
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if root :
            stack =[]
            ans = []
            while stack or root:
                if root:
                    stack.append(root)
                    root = root.left
                else:
                    root = stack.pop()
                    ans.append(root.val)
                    root = root.right
            return ans
        else:
            return []

```

注意这个写法，关键在于不断地移动head，可以画一个树来去看一看，首先看栈和head，如果head一直有，那么就会一直压进栈，如果栈不是空，但head到空了，说明到头了，此时head要回到上一个节点，然后打印，然后跑到右边继续执行1

## 后序遍历-非递归-两个栈

回想我们刚才的先序，是中左右，如果我们压栈的时候是先压左，再压右，那么就是 中右左，中右左完全反过来就是左右中，即后序

```python 
   def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if root == None:
            return []
        stack = []
        stack.append(root)
        ans = []
        final = []
        while stack:
            temp = stack.pop()
            ans.append(temp.val)
            if temp.left:
                stack.append(temp.left)
            if temp.right:
                stack.append(temp.right)
        while ans :
            final.append(ans.pop())
        return final

```

## 后序遍历-非递归-一个栈

如果要用一个栈的话，需要两个指针，一个cur，一个h，重点在这个h上，h负责记录，如果没有打印过节点，h就一直是头节点，一旦打印过，那么h就移动到打印的节点，此后h的含义是 上一次打印的节点

流程如下，while栈不是空

cur是栈的peek

当cur.left不是None,h不是left，h不是rigth（意思就是说，有左数，并且左数还没处理）：把cur.left压入栈

如果cur.right不是空，并且h不是right的话，就把cur.right 压入栈（意思就是有右树，并且右数还没处理过）

如果都不是，说明cur现在都没处理，并且到头了，此时打印，h记录到打印的那个位置


```python 
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        h = root
        stack = []
        stack.append(root)
        ans = []
        while stack:
            cur = stack[-1]
            if cur.left and h != cur.left and h != cur.right:
                stack.append(cur.left)
            elif cur.right and h != cur.right:
                stack.append(cur.right)
            else:
                ans.append(stack[-1].val)
                h = stack.pop()
        return ans 
```
very的复杂我只能说

