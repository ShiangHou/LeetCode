# 判断平衡二叉树
力扣110
## 初步思路
所谓的平衡二叉树，就是说一个二叉树，他的左右子树的高度相差不超过1

看到题目，感觉very的简单啊，我们之前求过树的最大高度啊，就是那个一行代码的，我们比较一下左右子树不就行了嘛

其实不是哈哈哈，我们之前求的是最大深度，但现在所有的子node都要判断，比如果一直右3个左树，一直有3个右数，这是最大深度一样的，但是对于任意一个子树而言，由于一边是none，所以就不满足

处理起来也很简单，每一个node都去判断一下就行


```python 
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        current = abs(self.depth(root.left) - self.depth(root.right))<=1
        return current and self.isBalanced(root.left) and self.isBalanced(root.right)
                
    
    def depth(self, node):
        if not node:
            return 0
        return max(self.depth(node.left)+1,self.depth(node.right)+1)


```

## 优化

上述方法是复杂度n2，因为每个都要走一遍。very的复杂，

改进的话就是需要改进depth函数，如果发现了不平衡，直接处理掉就行。

在depth函数里面，如果发现不平衡，返回-1就行

这种也叫做后序遍历

```python
 def isBalanced(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        return self.depth(root) != -1
                
    
    def depth(self, node):
        if not node:
            return 0
        #看一下左子树
        left_height = self.depth(node.left)
        if left_height == -1:
            return -1
        #看一下右子树
        right_height = self.depth(node.right)
        if right_height == -1:
            return -1
        #看一下当前节点
        if abs(left_height-right_height)>1:
            return -1
        
        #返回当前节点的最大高度
        return max(left_height,right_height)+1

```

