# 有效的字母异位词
力扣242
## 初步思路

首先看一下题目，题目要求我们去判断两个字符串是不是所谓的字母异位词，那么首先要明白一点什么是字母异位词，这个感觉就是字面意思，如果是相同的字母的不同排列组合的话，那么就是所谓的字母异位并且这个应该是只能使用一次应该

那么一个大体的想法就是，拿这个字符串，从左往右遍历，对于每一个元素来说的话，如果在另一个字符串里面出现过，那么就是对的，此时将这个元素删除掉，然后继续遍历就行

此时可以发现，我需要一种数据结构，可以给一个元素，判断元素在不在里面，然后返回下标

## ASCII 构建hash
在构建哈希之前，我们需要先了解一些底层的知识，首先就是ASCII。对于计算机而言，他们并不会理解字母，通常是把字母通过一个映射表映射为整数，比如 “a”的ASCII 为97，“b”的ASCII为98 等等

值得注意的是，当我们把所有的字母的ASCII都减去a的ASCII（即减去97）的时候，我们，可以发现，从a-z的ASCII都会被映射成0-25

这就是一个very简单，并且高效的hash表，因为我可以根据任意的一个数字去找到对应的字母是啥

在python中，使用ord()来获取某一个某一个字母的ASCII的值




## 初步思路
有了ASCII构建的基础，回看这道题，根据原来的思路，我需要将另一个字符串的字母转化为一个hash，但现在有了所有的字母的hash，思路就可以改变一下

下面我只需要一个由26个字母组成的hash数组就行（a-z对应下标0-25，背后理解），然后所有都变成0.在遍历第一个字符串的时候，将对应位置的数组的元素都+1，在遍历第二个字符串的时候，将对应数组的元素都-1，这样两遍扫完，看一下hash中是不是全是0，如果全是0，说明两个字符串的构成元素是一样的，如果出现1或者多了-1，说明不一样

```python
def isAnagram(self, s: str, t: str) -> bool:
    hash_nums = [0]*26
    for i in s:
        hash_nums[ord(i)-97] += 1
    for j in t:
        hash_nums[ord(j)-97] -= 1
    for k in hash_nums:
        if k != 0:
            return False
    return True   
```

查看答案发现答案和我们一样