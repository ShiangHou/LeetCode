# KMP 算法
问题：一个字符串a，一个字符串b，a字符串包含了b字符串，需要返回a中包含字符串的开始的下标

比如abcdecd，cd，那么就需要返回2（2和5也可以，一般是最左边，kmp都支持）

不包含的话返回-1

暴力方法就是说，挨个挨个去试就行了，复杂度是O(nm)

KMP可以做到m+n，具体的思想是，我们在暴力解法的时候做了很多的无用功，当一次失败的时候，是继续i+1，从而导致重复

## 最长公共前后缀
前缀 (Prefix)：包含字符串首字母，但不包含尾字母的所有子串
后缀 (Suffix)：包含字符串尾字母，但不包含首字母的所有子串。

比如说ABA，那么前缀就是 A AB （不包含最后一个A，所以没有ABA），后缀就是A，BA

所以对于ABA来说，最长公共前缀就是A，长度为1


## next数组
考虑到整个的数组，比如一个数组是ABABC，我们需要分析每一个小部分的最长公共前后缀

A       无前缀       无后缀        无公共    0  

AB      A           B            无公共    0

ABA     A,AB        A,BA         A      1

ABAB    A,AB,ABA    B,AB,BAB     AB       2

ABABC   A,AB,ABA,ABAB  C,BC,ABC,BABC   无公共   0

注意，next数组当走到下标i的时候，应该是**不含当前i**，即i前面的那一串字符串的最长公共前后缀的长度，i为0的时候next数组是-1,i为1的时候是0（因为只有一个元素）
## 有next数组怎么加速
下面假设我们已经有了next数组

由于之前的暴力解法是，一些匹配过的还需要再进行匹配计算（算完0-10，发现11不匹配，然后还会从1往后开始，但其实在刚才算0-10的时候已经算过了1，这就是重复计算）

所以说，对于长的字符串，最好是不要重复匹配。

下面说一下KMP的流程，我们需要准备两个字符串，一个是s1，一个是s2，一个是s2的next数组

s1:    A B A B D A B A B C

s2:    A B A B C

next:[-1,0,0,1,2] #不需要最后一个0了，因为如果最后一个匹配上了，就行，匹配不上也不会有下下一个让你去试

整个流程是：

首先比较s1[i]和s2[j],i和j都是从0开始，s1[0]和s2[0],如果一样，就继续i++，j++，s1[1]和s2[1]

当比较到4时，发现s1[4]和s2[4]不一样（因为C和D不一样），在这个位置上的next是2（即ABAB字符串的最长公共）

此时要去看上一个匹配成功的到了哪里，沿着2去找s2的2位置，即滑动s2，让s2和s1的2位置匹配，即

s1:    A B A B D A B A B C

               i

s2:        A B A B C

               j

next      -1,0,0,1,2

此时j指针跳到s2的2位置，i指针依旧纹丝不动（就是为了让他别滑动）

此时继续走循环，但发现还是不匹配，继续，j位置上的next是0，那么j直接滑到0

s1:    A B A B D A B A B C

               i

s2:            A B A B C

               j

next          -1,0,0,1,2

此时发现还是不匹配，但是已经滑到了0位置（next是-1）说明就不能用i位置来开头，此时i++，j++

s1:    A B A B D A B A B C

                 i

s2:              A B A B C

                 j

next            -1,0,0,1,2

然后我们继续走，最后发现j走到了len(s2)，此时跳出循环（或者说i走到len(s1)），最后返回，如果j不是len(s2)，说明一直没匹配上，返回-1，匹配上了，返回i-j就行（i是s1匹配到的最后一个下标，减去s2的长度，就是开头）

## KMP流程的原理
核心在于s2的next数组。

注意到，当出现不匹配的时候

s1:    A B A B D A B A B C

               i

s2:    A B A B C

               j

next  -1,0,0,1,2

此时，我们发现，对于字符串ABAB，公共长度是2，那么s2中前后的AB 和 AB一定是一样的，并且由于刚才的滑动，s1的ABAB和s20-4它也是一样的，这样就说明：

s1:    A B (A B) D A B A B C

               i

s2:    (A B) A B C

               j

next  -1,0,0,1,2

上面打括号的一定是相等的，所以0-j一定是在原字符串匹配到的，因此我可以直接让i不动，让j划过去，继续从这一部分开始匹配就行

那么整个kmp主流程的代码就是
```python
def KmpSearch(s1 : str,s2 : str)->int:#这里假设已经有了一个next_nums
    if not s2:
        return 0
    n,m = len(s1),len(s2)
    next_nums = get_NextNums(s2)#这里假设已经有了一个next_nums
    i,j = 0,0
    while i < n and j <m:
        if j == -1 or s[i] == s[j]:
            i += 1
            j +=1
        else:
            j = next_nums[j]
    return i-j if j == m else -1
```


## next数组的快速实现

next数组的快速实现也是自己和自己进行KMP

有点类似于动态规划，根据我前面的next值去求解当前的next值

首先开始填0 1 2位置，2位置如果说0 1位置都是一样的就是1，否则就是0

例子

    a b a t a b a s a b a t a b a s ?

    0 1 2 3 4 5 6 7 

next                              7

现在要找？位置的，？位置的先看它上一个，即s位置的next是7，那么就走到数组7位置下，可以发现数组7位置正好也是s，于是？位置就7+1，即是8

当然还会进行多跳

比如

     a b a t a b a t a b a t a b a s ?

     0 1 2 3 4 5 6 7 

next       1       3               7

跳到7位置，发现不等于，就继续跳，跳到3，发现3位置等于，于是就是3+1=4（基于t位置的next） 

也可以继续跳，跳到头也没跳出来，最后就是0

原理和KMP差不多，都是看前缀相等来去弄的
代码应该是如下

```python 
def get_next_nums(s:str)->list:
    if len(s) == 1:
        return [-1]
    
    ans = [0]*len(s)
    ans[0],ans[1] = -1,0
    cn = 0#cn表示当前要和前一个字符对比的下标（就是i-1位置的next的指向的，由于i从2开始，1位置的next是0，所以这里也是0）
    i = 2#从2开始
    while i < len(s2):
        if s[i-1] == s[cn]:
            cn += 1
            ans[i] = cn
            i +=1
        elif cn >0: #不等于，继续跳
            cn = ans[cn]
        else:#跳不动了
            ans[i] = 0
            i += 1
    return ans
```