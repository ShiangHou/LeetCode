# 移除链表元素
力扣203 https://leetcode.cn/problems/remove-linked-list-elements/

# 初步思路
首先链表的题最后都要返回一个头节点，所以先考虑这个。分析可以发现，如果原始链表的第一如果是等于val的话，那么就要把这个给释放掉，然后直到找到那个不是val的，如果发现没有，自然最后就反悔false

当找到第一个不为val的后，立即把他链接到ans，最后就返回它就行了

下面思考一下整个过程，需要准备几个指针可以完成。我的head现在保证不是val了，下面开始遍历，这个过程是，遍历每一个链表(所以说需要一个cur来去遍历)，让遇到是val的时候，需要将这个节点抛弃，抛弃的时候，让这个节点的上一个元素指向这个节点的下一个元素就行，所以需要记录一下上一个元素（需要一个pre指针），可能还需要一个中间变量temp（即先存下cur.next,然后让pre指向cur.next,cur指向空，然后cur往下走就行）

还有一个要注意的是，如果遇到了cur=val，那么最后pre还是那个pre，不要往下走，如果cur不是val，那么cur和pre都往下走就行，直到cur是None

```python 
def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        #首先需要找到最后返回的头
        ans = None
        while head != None:
            if head.val != val:
                ans = head
                break
            else:
                head = head.next
        #如果遍历完所有的都没找到，说明全部都是val，此时直接返回就行 
        if ans == None:
            return None
        #下面开始，准备两个指针，一个pre一个cur
        pre,cur = ans,ans.next
        while cur != None:
            if cur.val == val:
                temp = cur.next
                pre.next = temp
                cur.next = None
                cur = temp
            else:
                cur = cur.next
                pre = pre.next
        return ans


```

## 优化

其实废话有很多，主要是不需要让当等于val的节点指向空就行。直接看一下cur.next.val是不是等于val，是的话直接让cur.next = cur.next.next就行了，也可以

```python 
 def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        #首先需要找到最后返回的头
        ans = None
        while head != None:
            if head.val != val:
                ans = head
                break
            else:
                head = head.next
        #如果遍历完所有的都没找到，说明全部都是val，此时直接返回就行 
        if ans == None:
            return None
        #下面开始，准备两个指针，一个pre一个cur
        cur = ans
        while cur.next != None:
            if cur.next.val == val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return ans


```
