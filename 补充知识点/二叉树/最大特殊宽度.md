# 二叉树的最大特殊宽度
力扣 662
## 思路

最大特殊宽度是指，最左边的不为空的节点，和最右边的不为空的节点相隔的长度，None也要算上

说白了，其实这个就是把数想想成一个完全的二叉树，找到不为none的宽度就行

那么对于一个完全的二叉树，我们有，第一个节点如果是1，那么对于所有的节点来说，节点i的左孩子是2*i，右孩子是2 *i+1 （如果第一个是0，那么就是2i+1和2i+2）。我们只需要把编号都编上，然后每一层统计的时候相减就可以

这道题目的解法也是very的简单，依旧是层序遍历，在遍历的时候呢，另外准备一个队列，用来统计他们的编号，然后相减就行

有一个小小的问题，因为树可能会隔着很多，所以怎么去做减这个动作

按照道理来说，应该就是一个队列的最后一个减去第一个就行（即队列中最后出来的和最先出来的，所以存一下他们就就行）

注意到我们会存一个size，那么我们可以直接访问下标就行哈哈哈哈哈，直接取出来

```python 
def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
    if not root:
        return 0
    id_dq = deque()
    node_dq = deque()
    ans = 0
    id_dq.append(1)
    node_dq.append(root)
    while node_dq:
        size = len(node_dq)
        #计算当前的宽度,注意最左边的在id_dq的0位置
        ans = max(ans,id_dq[size-1]-id_dq[0]+1)
        for _ in range(size):
            temp = node_dq.popleft()
            temp_id = id_dq.popleft()
            if temp.left:
                node_dq.append(temp.left)
                id_dq.append(temp_id*2)#左id
            if temp.right:
                node_dq.append(temp.right)
                id_dq.append(temp_id*2+1)
    return ans

```

