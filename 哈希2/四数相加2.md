# 四数相加2
力扣454

## 初步思路

先复述一遍题目：
题目要求说给了四个数组，这四个数组的长度都是n，问有多少种组合，使得四个数组各出一个数，让他们相加等于0

初步的想法自然是说疯狂的遍历，这样复杂度是n的4次方，

一个进阶的想法是，我肯定要找到这四个数组所有元素相加的所有可能，这四个数相加的可能性是一共有n4个，那么我可以准备一个n4的数组（或者说是矩阵），然后把每一个数组按照位置往里面填，最后扫一遍矩阵看看谁是0就行。但这样在填表的时候复杂度是4n，但最后扫一遍矩阵的时候，还是没有逃离出n4的复杂度

分析一下，刚才的两个想法都是需要找到所有组合的可能性，有没有不需要找所有组合的可能性，就像刚才提到的，我把那个n4的矩阵用另一个数据结构给换掉，那么最后的复杂度就可以降下去

这道题在hash表里面，那么考虑如何用hash表来去表达这个新的数据结构。hash最常用的，一个是数组ASCI去构建，一个是集合set，一个是字典，对于本题，set会对数组做去重，所以选择用字典

一个思路突然浮现了出来，我把每一个数组都做成一个字典，key是数组的第i个元素值，value是重复出现的次数

首先，我把一个数组转化为**所有元素以及对应的次数**,比如一个数组是[3,3],那么构建的dict就是{3:2},即3元素出现了两次。

但是好像还是不太行哎，这样也是需要从每一个数组里面来去弄。回想我们之前在计算两数之和的时候，我们将一个数与target的差放入到了dict里面，如果说是遇到差了，那么就找到了之和，所以现在也可以这样，我们将3个数组的和都加在一起，这样就是n3的复杂度，然后再遍历另一个数组，如果遇到了+=0的，那么就说明有，这样复杂度就可以降到n3

能不能再降低呢，拷打了一下好厚米Gemini，厚米和我说，可以直接分开用两个数组。因为是4个数组，先两个两个计算，然后如果在计算两个的时候，发现有-sum在dict中出现，说明加一起就是0，此时记录一下就行

梳理一下思路，嵌套两个for循环，都存入dict

在嵌套两个for，看有没有-sum在dict，没有的话就继续，有的话ans+=1（感觉不用再放入dict啊，因为是四个数不是两个数组本身

```python 
def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        ans = 0
        half_dict = {}
        for i in range(len(nums1)):
            for j in range(len(nums2)):
                half_dict[nums1[i]+nums2[j]] = (i,j)
        
        for a in range(len(nums3)):
            for b in range(len(nums4)):
                if -(nums3[a]+nums4[b]) in half_dict:
                    ans += 1
        return ans

```

发现这样其实过不了，分析一下，原来是如果重复的，那么会不断刷新这个(i,j)的值，这样是不行的，所以想办法把重复的算上。好厚米和我说，既然i,j用不上，那就把value存为这个key出现的次数就行，最后统计次数就可以

注意一下，如果初始不是0的话，那么就会报错，所以要把初始值设为0

```python 
def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:
        ans = 0
        half_dict =defaultdict(int)
        for i in nums1:
            for j in nums2:
                half_dict[i+j] += 1
        
        for a in nums3:
            for b in nums4:
                if -(a+b) in half_dict:
                    ans += half_dict[-(a+b)]
        return ans
```
记得从collections import一个defaultdict