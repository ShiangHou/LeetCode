# 滑动窗口的最大值
力扣 239
## 思路

看了单调队列的教程，复述一遍

单调队列的经典问题是，解决在滑动窗口中的最大值和最小值的问题,构造的队列如下（以最大值为例）准备一个长度和整体长度大小一样的队列（数组）

[       ]
大 ----> 小

当滑动窗口r++的时候，此时需要进入队列，为了维持住队列从左往右的特点，需要和队尾进行比较，如果比队尾大，就让队尾弹出，直到没有/不比队尾大，自己再进去

如果需要去输出最大值，直接输出队列的头就行

如果l++，那么就看r移走的位置的在不在双端队列里面的就行，如果在的话就直接移走就可以

注意，左神讲解的双端队列使用数组实现的，并且数组里面只存了下标，用两个指针来去维护双端队列，就像刚才说的一样，在移走的时候看移走的下标在不在双端队列里面就行。对于本题而言，其实可以直接看移动的数字是不是最大值，如果是的话就弹出（但这样要求，加入的时候是完全大于才会弹出，如果是等于的话也直接加进去就行，但是左神的那个大于/大于等于都可以，因为是按照下标来的）

梳理一下思路
首先准备一个deque，先把前k个放进去，放的时候，由于，如果太大的话，需要不断弹出，所以这个用while来去写

放入k个后，下面考虑怎么去写这个滑动的过程。感觉要写两个指针来去弄这个滑动，经过第一轮后，整个窗口应该是0，k-1，两个指针ij来去模拟，while循环用i< len ,然后放入nums[i]，弹出nums[j],并且加入到ans中，就行

```python 
def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
    from collections import deque
    q = deque()
    ans = []
    for i in range(k):
        while q and nums[i] > q[-1]:
            q.pop()
        q.append(nums[i])
    ans.append(q[0])
    i,j = 0,k-1
    while j < len(nums)-1:#第一波已经结束，弄好倒数第一波就行
        #加nums[j]
        while q and nums[j+1] > q[-1]:#加的是下一个
            q.pop()
        q.append(nums[j+1])
        #弹出nums
        if q[0] == nums[i]:#弹出的是当前的
            q.popleft()
        #记录ans
        ans.append(q[0])
        i+=1
        j+=1
    return ans

```
